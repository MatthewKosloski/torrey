\documentclass[12pt]{report}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{subfig}
\usepackage{fontspec}
\usepackage{setspace}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = black, %Colour of internal links
}

\usepackage[a4paper,
 	left=1in,
 	right=1in,
 	bottom=1in,
 	top=1in]{geometry}
 	 	
\graphicspath{ {./img/} }

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\setmainfont{Times New Roman}

\singlespacing

\begin{document}
\begin{center}
	\textbf{{\LARGE Undergraduate Research Grant Proposal}}
\end{center}

\section*{{\large Project Title}}
A Compiler for a Lisp-like Programming Language

\section*{{\large Introduction}}
Algorithms that are employed to solve computational problems must be implemented in some \textit{high-level programming language}.  That is, a language that abstracts away the many low-level details of the computer (e.g., registers, memory addresses, the stack, calling conventions, etc.), thereby making it loosely coupled to the hardware. These high-level languages contrast greatly to low-level languages (e.g., assembly languages), which are very tightly coupled to a computer and its architecture.  While this abstraction has facilitated accessibility and the speed at which programming can take place, it has simultaneously (by design) ``shielded'' programmers, many of whom take the abstraction for granted.
There are several different ways of implementing a high-level programming language, one of which is \textit{compilation}.  A \textit{compiler} is a computer program that translates a program written in a source language to an equivalent program in a target language.
In an attempt to better my understanding of the low-level details that high-level languages abstract away, I am proposing that I implement my own novel programming language.  I propose that the language be ``Lisp-like'', meaning its \textit{syntax} (form) and \textit{semantics} (meaning) will be inspired by a Lisp language.  Moreover, I propose that the language be implemented by constructing a compiler to translate the Lisp-like high-level language to an equivalent program in either LLVM IR or x86-64 assembly code.

\section*{{\large Significance}}
As stated in [1], ``compiler writing touches upon programming languages, machine architecture, language theory, algorithms, and software engineering''.  Clearly, building a compiler is no small feat and there are many lessons to be learned.  Additionally, because the university does not offer an undergraduate course in compilers, I firmly believe this project would be a great opportunity to broaden my computer science education.

\section*{{\large Literature Review}}
There are several approaches to building compilers.  The typical and ``old school'' approach, as articulated in [1], is to decompose the compiler into a number of small passes. Alternatively, as proposed by [2], a compiler can be decomposed into many small, fine-grained ``nano passes'', each of which performs a single task.  I intend to adopt a mixture of these two approaches.

\section*{{\large Project Objectives}}
\begin{itemize}
 	\item Perform lexical analysis, syntax analysis, semantic analysis, and other compiler passes
 	\item Apply tree traversals to convert an abstract syntax tree to an intermediate representation
	\item Perform standard compiler optimizations
	\item Allocate CPU registers using an algorithm
	\item Generate either LLVM IR or efficient x86-64 assembly code
\end{itemize}

\section*{{\large Preliminary Work}}
In the Spring 2020 semester, I took CS 316 Programming Languages.  The course was theoretical, and I never had an opportunity to build my own programming language.  However, after taking the course, I decided to apply my knowledge to construct a simple interpreter for a tiny Lisp-like programming language (an \textit{interpreter} is another way of implementing a programming language, an alternative to compilation).\footnote{\href{https://github.com/MatthewKosloski/truncated-tarantula}{The source code for my interpreter, codenamed ``Truncated Tarantula''}}  During the development of the interpreter, I consulted \textit{Crafting Interpreters}, which is a textbook that instructs the reader on how to built a tree-walk interpreter for a programming language.  Although I did not ``finish'' the programming language, I was able to implement the following: binary arithmetic, lexically-scoped variables, booleans, strings, signed integers, signed real numbers, and control flow.

\section*{{\large Research Design, Methodology, and Activities}}
Conforming to the Agile software development methodology, I propose an incremental approach to the development of my compiler.  That is, I intend to build not one compiler, but \textit{five}, each of which building upon the previous by adding more features:

\begin{enumerate}
	\item \textbf{[Jan 11-Feb 08]:} integer, unary, and binary expressions and standard output
	\item \textbf{[Feb 08-Mar 01]:} lexically-scoped variables via a \lstinline{let} expression
	\item \textbf{[Mar 01-Mar 22]:} booleans, logical and relational operators, and control flow
	\item \textbf{[Mar 22-Apr 12]:} globally-scoped functions via a \lstinline{fun} expression
	\item \textbf{[Apr 12-May 03]:} loops
\end{enumerate}
For illustrative purposes, here is the context-free grammar that will be implemented by the first compiler's parser:
\begin{lstlisting}
program       -> expression* ;
expression    -> integer
               | unary
               | binary
               | print ;
integer       -> [0-9]+ ;
unary         -> "(" "-" expression ")" ;
binary        -> "(" ("+" | "-" | "*" | "/") expression expression ")" ;
print         -> "(" ("print" | "println") expression+ ")" ;
\end{lstlisting}

\clearpage

\section*{{\large References}}
\begin{enumerate}
	\item[\text{[1]}] Aho, Alfred V., et al. "Introduction." \textit{Compilers: Principles, Techniques, and Tools}, 2nd ed., Pearson Higher Ed, 2011
	\item[\text{[2]}] SARKAR, DIPANWITA, OSCAR WADDELL, and R. K. DYBVIG. \textit{"EDUCATIONAL PEARL: A Nanopass framework for compiler education."} Journal of Functional Programming 15, no. 05 (2005), 653
\end{enumerate}



\end{document}
